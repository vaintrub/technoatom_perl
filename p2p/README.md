P2P-клиент для обмена файлами
=============================

Необходимо написать асинхронный P2P-клиент с использованием `AnyEvent` или `Coro`.
Клиенты (peer'ы) должны уметь взаимодействовать между собой и обмениваться блоками файлов, а также
имеющейся у них информацией об известных peer'ах. Первоначальная выдача файлов для раздачи и
подключение к "кластеру" клиентов осуществляется сервером-арбитром (арбитр предоставляется
готовый, переписывать его не нужно). Он же выполняет проверку правильности скачивания файлов.

Цель клиента - максимально быстро собрать как можно больше файлов целиком и уведомить о них арбитра.
При этом запрещается создавать искуственные препятствия для получения информации для других peer'ов
(кроме ограничений, явно указанных в ТЗ). Автор статистически самого быстрого и корректно работающего
клиента получит дополнительные баллы за работу. 


Алгоритм работы клиента:
---

* Перед работой подключиться к арбитру
    * передать информацию о себе 
    * получить информацию об известных арбитру peer'ах
    * запросить у арбитра файлы для обмена c другими peer'ами

* В процессе работы параллельно принимать входящие соединения от других peer и коннектиться к другим peer
самостоятельно. При установлении соединения с другими клиентами:
    * обменяться имеющейся информацией о peer'ах
    * передать друг другу имеющиеся блоки файлов (блоки должены выбираться случайным образом, с определенным лимитом)

* После того, как peer считает, что он собрал какой либо файл, он отправляет его на проверку арбитру
* По истечение определенного в конфигурации арбитра времени, он подведет итоги - какой peer собрал больше всех файлов

Протокол взаимодействия
=======================

Handshake
---
Любое соединение должно быть подтвержденно рукопожатием. Принимающая сторона (сервер) отправляет в ответ на соединение сообщение с некоторым токеном и ожидает получить его в ответ. Если этого не происходит, то сервер должен оборвать соединение.

Если рукопожатие прошло успешно, то в рамках этого же соединения происходит отправка команды и получение на нее ответа.

Формат
```
[MAGIC][TOKEN]
```
* `MAGIC` (char(4)) - некоторая байтовая строка из 4х символов. Принимает значения: `ARBT` (соединение с арбитром), `PEER` (соединение с пиром), `HELO` (ответ на рукопожатие)
* `TOKEN` (uint32) - случайный числовой идентификатор

Пример рукопожатия с арбитром
```
ARBT\x01\x45\xFF\x0B # пакет отправляемый арбитром клиенту
HELO\x01\x45\xFF\x0B # пакет ожидаемый арбитром в ответ
```

Пример рукопожатия с пиром
```
PEER\x01\x45\xFF\x0B # пакет отправляемый пиром клиенту
HELO\x01\x45\xFF\x0B # пакет ожидаемый пиром в ответ
```

Общий формат запроса/ответа.
---

Запрос
```
[MSG_ID][MSG_BODY_LEN][MSG_BODY]
```
* `MSG_ID` (uint8) - идентификатор типа сообщения
* `MSG_BODY_LEN` (uint32) - длина тела запроса
* `MSG_BODY` (bytes) - тело запроса длиной `MSG_BODY_LEN`

Ответ
```
[RESP_CODE][RESP_BODY_LEN][RESP_BODY]
```
* `RESP_CODE` (uint8) - код ответа
* `RESP_BODY_LEN` (uint32) - длина тела ответа
* `RESP_BODY` (bytes) - тело ответа длиной `RESP_BODY_LEN`

Типы сообщений
---
* `MSG_GET_PEERS  = 1` - запрос известных пиров у арбитра или пира
* `MSG_GET_FILES  = 2` - запрос кусочков (чанков) файлов у арбитра или пира
* `MSG_CHECK_FILE = 3` - проверка правильности файла у арбитра

Коды ответов
---
* `RESP_CODE_OK                   =   0` - операция произведена успешно
* `RESP_CODE_ERR_MD5              =   1` - ошибка проверки контрольной суммы
* `RESP_CODE_ERR_UNKNOWN_FILENAME =   2` - неизвестное имя файла
* `RESP_CODE_ERR_UNKNOWN_MSG      =   3` - неизвестная команда
* `RESP_CODE_ERR_LESS_PEERS       = 251` - недостаточно пиров для запуска обмена (арбитр)
* `RESP_CODE_ERR_UNKNOWN_PEER     = 252` - незарегестрированный пир (арбитр)
* `RESP_CODE_ERR_ILLEGAL_MODE     = 253` - команда недоступна в текущем режиме (арбирт)
* `RESP_CODE_ERR_FATAL            = 255` - фатальная ошибка


MSG_GET_PEERS (1)
---

Запрос
```
[UUID_BIN][IP_NET][PORT]
```
* `UUID_BIN` (bytes(16)) - уникальная последовательность из 16 байт (UUID), представляющая собой уникальный идентификатор пира (http://search.cpan.org/~caugustin/UUID-Tiny-1.04/lib/UUID/Tiny.pm)
* `IP_NET` (bytes(4)) - IP адрес (в сетевом формате (*inet_aton*)), на котором данный пир готов принимать сооединения
* `PORT` (uint16) - порт, на котором данный пир готов принимать сооединения

Ответ
```
[PEERS_CNT]([UUID_BIN][IP_NET][PORT])*
```
* `PEERS_CNT` (uint16) - количество пиров в ответе
* `UUID_BIN` (bytes(16)) - UUID пира
* `IP_NET` (bytes(4)) - IP адрес пира
* `PORT` (uint16) - порт пира

MSG_GET_FILES (2)
---

Запрос
```
[UUID_BIN]
```
* `UUID_BIN` (bytes(16)) - UUID пира, который инициировал запрос

Ответ
```
[CHUNKS_CNT]([FILE_ID][FILE_CHUNKS_CNT][CHUNK_NUM][CHUNK_LEN][CHUNK_BIN_DATA])*
```
* `CHUNKS_CNT` (uint16) - количество чанков в ответе
* `FILE_ID` (chars(32)) - уникальное символьное имя файла
* `FILE_CHUNKS_CNT` (uint8) - количество чанков, на которое разбит файл
* `CHUNK_NUM` (uint8) - номер отдаваемого чанка
* `CHUNK_LEN` (uint16) - длина отдаваемого чанка в байтах
* `CHUNK_BIN_DATA` (bytes) - тело чанка, длиной `CHUNK_LEN`

MSG_CHECK_FILE (3)
---

Запрос
```
[UUID_BIN][FILE_ID][FILE_DATA_MD5]
```
* `UUID_BIN` (bytes(16)) - UUID пира, который инициировал запрос
* `FILE_ID` (char(32)) - имя проверяемого файла
* `FILE_DATA_MD5` (bytes(16)) - контрольная сумма (md5) тела файла, в виде 16ти байтовой бинароной последовательности

Ответ
Тела у ответа нет. Успешость проверки определяем по коду ответа.

Цикл жизни клиента с учетом протокола
=====================================

Инициализация
-------------

* открыть "входящий" порт
* подключиться к арбитру с командой `MSG_GET_PEERS`
* подключиться к арбитру с командой `MSG_GET_FILES`
* сразу после успешного выполнения данных команд приступить к взаимодействию с другими клиентами

P2P-взаимодействие с клиентами
------------------------------

* устанавливать исходящие соединения с произвольными клиентами и обмениваться информацией при помощи
команд `MSG_GET_PEERS`, `MSG_GET_FILES`; алгоритм выбора клиентов и отправляемых им команд остается
на усмотрение разработчика
* принимать входящие соединения от других клиентов и обрабатывать поступающие от них
команды `MSG_GET_PEERS`, `MSG_GET_FILES`
* обрабатывать полученную от других клиентов информацию; при обнаружении полностью собранных файлов
уведомлять о них арбитра при помощи команды `MSG_CHECK_FILE`; в случае если файл собран неправильно -
попытаться исправить ошибки
* в случае, если удалось успешно собрать все участвующие в раздаче файлы, перестать устанавливать
исходящие соединения с другими клиентами, но продолжать обрабатывать "входящие" соединения

Дополнительные особенности
==========================

* с целью синхронизации запуска раздачи арбитр может (и будет) залипать во время общения с клиентами,
клиенты должны быть к этому готовы
* арбитр передает все чанки, выделенные для раздачи клиенту, за один раз; повторное обращение к арбитру
приводит к выдаче тех же самых чанков
* клиенты должны получать в командной строке адрес арбитра, адрес для открытия "входящего" порта,
количество чанков для выдачи другим клиентам в рамках одной команды `MSG_GET_FILES`
